如果需要代理一个类，而不是一个或多个接口，该怎么办?

想象一下，在我们前面的例子中，没有Person接口。我们需要通知一个名为Person的类，它没有实现任何业务接口。在这种情况下，您可以配置Spring来使用CGLIB代理，而不是动态代理。为此，将前面显示的ProxyFactoryBean上的proxyTargetClass属性设置为true。虽然最好是对接口而不是类进行编程，但是在处理遗留代码时，建议不实现接口的类的能力可能很有用。(一般来说，春天是没有规定性的。虽然它使应用良好的实践变得容易，但它避免强制采用特定的方法。

如果愿意，您可以在任何情况下强制使用CGLIB，即使您有接口。

CGLIB代理通过在运行时生成目标类的子类来工作。Spring将这个生成的子类配置为将方法调用委托给原始目标。子类用于实现装饰器模式，在通知中编织。

CGLIB代理通常应该对用户透明。但是，有一些问题需要考虑:

- 不能建议使用`final`的方法，因为它们不能被覆盖。
- 没有必要将CGLIB添加到类路径中。从Spring 3.2开始，CGLIB被重新打包并包含在Spring -core JAR中。换句话说，与JDK动态代理一样，基于cglib的AOP工作“开箱即用”。


CGLIB代理和动态代理之间的性能差别不大。从Spring 1.0开始，动态代理稍微快了一点。然而，这种情况在未来可能会改变。在这种情况下，业绩不应是决定性的考虑因素。